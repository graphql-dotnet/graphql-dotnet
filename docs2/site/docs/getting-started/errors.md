# Error Handling

Errors within the GraphQL engine can be thought of as falling into one of three groups: schema errors, input errors, and processing errors.  For instance, if an invalid query was passed to the `DocumentExecuter`, it would be considered an input error, and a `SyntaxError` would be thrown. Or if an invalid enum string was passed as a variable to a query, an `InvalidValueError` would be thrown. All validation rules that fail their respective tests are treated as input errors.  Processing errors typically represent unanticipated exceptions occurring during the execution of a field resolver, such as a timeout during a database operation.

Input errors and processing errors are returned from the `DocumentExecuter` within the `ExecutionResult.Errors` property as a list of `ExecutionError` objects.  `ExecutionError` inherits from `Exception`, and the `Message` property is serialized according to the spec with location and path information.  In addition, three additional pieces of information are serialized to the `extensions` property of the GraphQL error which contain:
* Within `code`, the `Code` property of the `ExecutionError`, if any,
* Within `codes`, the `Code` property of the `ExecutionError` along with generated codes of any inner exceptions, if any, and
* Within `data`, the contents of the `ExecutionError.Data` property, which by default contains the data of the inner exception, if any.

Note that by default, messages from unhandled processing errors are masked and a generic "Error trying to resolve product" or similar error is returned.

Here is a sample result of a `FormatException` thrown within a `product` field resolver (a processing error):
```json
{
  "errors": [
    {
      "message": "Error trying to resolve product.",
      "locations": [
        {
          "line": 3,
          "column": 5
        }
      ],
      "path": [
        "product"
      ],
      "extensions": {
        "code": "FORMAT",
        "codes": [
          "FORMAT"
        ]
      }
    }
  ]
}
```

## Schema Errors

Schema errors throw an exception during the process of defining or building the schema. For instance, adding a two fields of the same name to a GraphQL type would result in an `ArgumentOutOfRangeException` while attempting to add the second field. Another example would be if a schema defined an invalid union; an error would be thrown while the schema was being initialized within `DocumentExecuter` and caught as an unhandled exception (see Processing Errors, below).

## Input Errors

All input errors generated by the GraphQL framework will derive from `DocumentError`. Below is a list of error messages and their respective error classes and codes:

Description | Error class | Code
-|-|-
Empty query document | NoOperationError | NO_OPERATION
Query parsing error | SyntaxError | SYNTAX_ERROR
Attempting a mutation or subscription when none are defined | InvalidOperationError | INVAILD_OPERATION
Invalid variable values | InvalidVariableError | INVALID_VALUE

Field resolvers can manually trigger an input error by throwing an exception of the `ExecutionError` type, or a derived type. Any other thrown error is treated as a processing error (see below). Below is an example of typical validation within a query or mutation that returns an input error:

```csharp
Field<NonNullGraphType<OrderGraph>>("order",
    arguments: new QueryArguments(
        new QueryArgument<NonNullGraphType<IntGraphType>> { Name = "id" }),
    resolve: context =>
    {
        var order = _orderService.GetById(context.GetArgument<int>("id"));
        if (order == null)
            throw new ExecutionError("Invalid order id");
    });
```

You can also add errors to the `IResolveFieldContext.Errors` property directly.

```csharp
Field<DroidType>(
  "hero",
  resolve: context => context.Errors.Add(new ExecutionError("Error Message"))
);
```

## Processing Errors

Processing errors should only occur if an exception is thrown from within a field resolver. For instance, if you execute `.Single()` on an empty array, causing an `InvalidOperationException` to be thrown. These types of errors are most likely to be bugs or connection problems, such as a connection error when communicating to a database. There are also two other types of processing errors to be aware of: (1) calling context.GetArgument<> with a type that does not match the argument type, when the system cannot perform the conversion – for instance, calling context.GetArgument<Guid>("arg") on an argument of type IntGraphType – and (2) returning data from a field resolver that does not match the graph type of field resolver, when the system cannot perform the conversion.

Processing errors can be thrown back to the caller of `DocumentExecuter.ExecuteAsync` by setting the `ExecutionOptions.ThrowOnUnhandledExceptions` property to true. When this property is set to false, the default setting, unhandled exceptions are wrapped in an `UnhandledError` and added with a generic error message to the `ExecutionResult.Errors` property. Error codes are dynamically generated from the inner exceptions of the wrapped exception and also returned along with data contained within the inner exception's `Data` property.

You can also handle these processing exceptions by setting a delegate within the ExecutionOptions.UnhandledExceptionDelegate property. Within the delegate you can log the error message and stack trace for debugging needs. You can also override the generic error message with a more specific message, wrap the exception in your own ExecutionError class, and/or set the codes as necessary.

Here is a sample of a typical unhandled exception delegate which simply logs the error to a database:

```csharp
var executer = new DocumentExecuter();
var result = executer.ExecuteAsync(options => {

    ...

    options.UnhandledExecutionDelegate = ctx =>
    {
        try
        {
            using var db = new MyDatabase();
            db.ErrorLogs.Add(new ErrorLog {
                DateStamp = DateTime.UtcNow,
                Message = ctx.Exception.Message,
                Details = ctx.Exception.ToString()
            });
            db.SaveChanges();
        }
        catch { }
    };
});
```









The `ExecutionResult` provides an `Errors` property which includes any errors encountered
during execution. Errors are returned [according to the spec](https://graphql.github.io/graphql-spec/June2018/#sec-Errors),
which means stack traces are excluded. The `ExecutionResult` is transformed to what the spec
requires using one or the another `IDocumentWriter`.

For example `GraphQL.NewtonsoftJson.DocumentWriter` uses [JSON.NET](https://www.nuget.org/packages/Newtonsoft.Json)
and `GraphQL.SystemTextJson.DocumentWriter` uses new .NET Core memory optimized serializer from
[`System.Text.Json`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json). For JSON.NET you can change
what information is provided by setting your values (`ContractResolver`, Converters`, etc.)
in `JsonSerializerSettings` passed to `DocumentWriter` constructor. For `System.Text.Json`
serializer you can configure `JsonSerializerOptions` passed to `DocumentWriter` constructor.

You can also implement your own `IDocumentWriter`.

To help debug errors, you can set `ExposeExceptions` on `ExecutionOptions` which will expose error stack traces.

```csharp
var executor = new DocumentExecutor();
ExecutionResult result = await executor.ExecuteAsync(_ =>
{
  _.Query = "...";
  _.ExposeExceptions = true;
});
```

You can throw an `ExecutionError` error in your resolver and it will be caught
and displayed. You can also add errors to the `ResolveFieldContext.Errors` directly.

```csharp
Field<DroidType>(
  "hero",
  resolve: context => context.Errors.Add(new ExecutionError("Error Message"))
);

Field<DroidType>(
  "hero",
  resolve: context => throw new ExecutionError("Error Message")
);
```

Also `ExecutionOptions.UnhandledExceptionDelegate` allows you to override, hide,
modify or just log the unhandled exception from your resolver before wrap it into
`ExecutionError`. This can be useful for hiding error messages that reveal server
implementation details.

```csharp
var executor = new DocumentExecutor();
ExecutionResult result = await executor.ExecuteAsync(_ =>
{
  _.Query = "...";
  _.UnhandledExceptionDelegate = context => context.ErrorMessage = "Error Message";
});
```

Set `ExecutionOptions.ThrowOnUnhandledException` to `true` in cases where the thrown exception needs to propagate to an enclosing or global handler.

Note that `UnhandledExceptionDelegate` will not be invoked in the case `ThrowOnUnhandledException` is `true`.

```csharp
try
{
  var result = await executor.ExecuteAsync(_ =>
  {
    _.Query = "...";
    _.ThrowOnUnhandledException = true;
  });
  
  //Process result...
}
catch (Exception ex)
{
  logger.Error(ex, "Error Message");
}
```

You can provide additional error handling or logging for fields by adding Field Middleware.
