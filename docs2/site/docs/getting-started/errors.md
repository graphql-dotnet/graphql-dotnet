# Error Handling

Errors within the GraphQL engine can be thought of as falling into one of three groups: schema errors, input errors and processing errors. For instance, if an invalid query was passed to the `DocumentExecuter`, it would be considered an input error, and a `SyntaxError` would be thrown. Or if an invalid enum string was passed as a variable to a query, an `InvalidValueError` would be thrown. All validation rules that fail their respective tests are treated as input errors.  Processing errors typically represent unanticipated exceptions occurring during the execution of a field resolver, such as a timeout during a database operation.

Input errors and processing errors are returned from the `DocumentExecuter` within the `ExecutionResult.Errors` property as a list of `ExecutionError` objects. `ExecutionError` inherits from `Exception`, and the `Message` property is serialized according to the spec with location and path information. In addition, by default three additional pieces of information are serialized to the `extensions` property of the GraphQL error which contain:
* Within `code`, the `Code` property of the `ExecutionError`, if any,
* Within `codes`, the `Code` property of the `ExecutionError` along with generated codes of any inner exceptions, if any, and
* Within `data`, the contents of the `ExecutionError.Data` property, which by default contains the data of the inner exception, if any.

Note that by default, messages from unhandled processing errors are masked and a generic "Error trying to resolve field '<FIELD_NAME>'" or similar error is returned.

Here is a sample result of a `FormatException` thrown within a `product` field resolver (a processing error):
```json
{
  "errors": [
    {
      "message": "Error trying to resolve field 'product'.",
      "locations": [
        {
          "line": 3,
          "column": 5
        }
      ],
      "path": [
        "product"
      ],
      "extensions": {
        "code": "FORMAT",
        "codes": [
          "FORMAT"
        ]
      }
    }
  ]
}
```

## Schema Errors

Schema errors throw an exception during the process of defining or building the schema. For instance, adding a two fields of the same name to a GraphQL type would result in an `ArgumentOutOfRangeException` while attempting to add the second field. Another example would be if a schema defined an invalid union; an error would be thrown while the schema was being initialized within `DocumentExecuter` and caught as an unhandled exception (see Processing Errors, below).

## Input Errors

All input errors generated by GraphQL.NET derive from `DocumentError`. Below is a list of error messages and their respective error classes and codes:

Description | Error class | Code
-|-|-
Empty query document | NoOperationError | NO_OPERATION
Query parsing error | SyntaxError | SYNTAX_ERROR
Attempting a mutation or subscription when none are defined | InvalidOperationError | INVAILD_OPERATION
Invalid variable values | InvalidVariableError | INVALID_VALUE
Validation errors | ValidationError | (varies)

Field resolvers can manually trigger an input error by throwing an `ExecutionError` or derived class. Any other thrown error is treated as a processing error (see Processing Errors below). Here is an example of typical validation within a field resolver that returns an input error:

```csharp
Field<NonNullGraphType<OrderGraph>>("order",
    arguments: new QueryArguments(
        new QueryArgument<NonNullGraphType<IntGraphType>> { Name = "id" }),
    resolve: context =>
    {
        var order = _orderService.GetById(context.GetArgument<int>("id"));
        if (order == null)
            throw new ExecutionError("Invalid order id");
    });
```

You can also add errors to the `IResolveFieldContext.Errors` property directly.

```csharp
Field<DroidType>(
  "hero",
  resolve: context => context.Errors.Add(new ExecutionError("Error Message"))
);
```

## Processing Errors

Processing errors should only occur if an exception is thrown from within a field resolver. For instance, if you execute `.Single()` on an empty array, causing an `InvalidOperationException` to be thrown. These types of errors are most likely to be bugs or connection problems, such as a connection error when communicating to a database. There are also two other types of processing errors to be aware of:

* Calling `context.GetArgument<>` with a type that does not match the argument type, when the system cannot perform the conversion â€“ for instance, calling `context.GetArgument<Guid>("arg")` on an argument of type `IntGraphType`, and
* Returning data from a field resolver that does not match the graph type of field resolver, when the system cannot perform the conversion.

Processing errors can be thrown back to the caller of `DocumentExecuter.ExecuteAsync` by setting the `ExecutionOptions.ThrowOnUnhandledExceptions` property to true. When this property is set to false, the default setting, unhandled exceptions are wrapped in an `UnhandledError` and added with a generic error message to the `ExecutionResult.Errors` property. Error codes are dynamically generated from the inner exceptions of the wrapped exception and also returned along with data contained within the inner exception's `Data` property.

You can also handle these processing exceptions by setting a delegate within the `ExecutionOptions.UnhandledExceptionDelegate` property. Within the delegate you can log the error message and stack trace for debugging needs. You can also override the generic error message with a more specific message, wrap or replace the exception with your own `ExecutionError` class, and/or set the codes and data as necessary. Note that if `ThrowOnUnhandledExceptions` is true, the `UnhandledExceptionDelegate` will not be called.

Here is a sample of a typical unhandled exception delegate which logs the error to a database.  It also returns the log id along with the error message:

```csharp
var executer = new DocumentExecuter();
var result = executer.ExecuteAsync(options => {

    ...

    options.UnhandledExecutionDelegate = context =>
    {
        try
        {
            using var db = new MyDatabaseContext();
            var errorLog = new ErrorLog {
                DateStamp = DateTime.UtcNow,
                Message = context.Exception.Message,
                Details = context.Exception.ToString()
            };
            db.ErrorLogs.Add(errorLog);
            db.SaveChanges();
            context.Exception.Data["errorLogId"] = errorLog.Id;
        }
        catch { }
    };
});
```

You can also override the serialized exception by setting `context.Exception`, or simply replace the message by setting `context.ErrorMessage` such as in this example:

```csharp
options.UnhandledExecutionDelegate = ctx =>
{
    if (ctx.Exception is SqlException)
        ctx.ErrorMessage = "A database error has occurred.";
};
```

## Error Serialization

After the `DocumentExecuter` has returned a `ExecutionResult` containing the data and/or errors, typically you will pass this object to an implementation of `IDocumentWriter` to convert the object tree into json. The GraphQL spec allows for four properties to be returned with each error: `message`, `locations`, `path`, and `extensions`. The `IDocumentWriter` implementations provided for the `Newtonsoft.Json` and `System.Text.Json` libraries allow you to control the serialization of `ExecutionError`s into the resulting json data by providing an `IErrorInfoProvider` to the constructor of the document writer. The `ErrorInfoProvider` class contains 5 properties to control serialization behavior:

* `ExposeExceptionStackTrace` when enabled sets the `message` property for errors to equal the exception's `.ToString()` method, which includes a stack trace. This property defaults to false.
* `ExposeCode` when enabled sets the `extensions`'s `code` property to equal the error's `Code` property. This property defaults to true.
* `ExposeCodes` when enabled sets the `extensions`'s `codes` property to equal a list containing both the error's `Code` property, if any, and the type name of inner exceptions (after being converted to UPPER_CASE and removing the "Extension" suffix). So an `ExecutionError` with a code of `INVALID_FORMAT` that has an inner exception of type `ArgumentNullException` would contain a `codes` property of `["INVALID_FORMAT", "ARGUMENT_NULL"]`. This property defaults to true.
* `ExposeData` when enabled sets the `extension`'s `data` property to equal the data within the error's `Data` property. This property defaults to true.
* `ExposeExtensions` when disabled hides the entire `extensions` property, including `code`, `codes`, and `data` (if enabled). This property defaults to true.

For example, to show the stack trace for unhandled errors during development, you might write code like this:

```csharp
#if DEBUG
    var documentWriter = new DocumentWriter(true, new ErrorInfoProvider(options => options.ExposeExceptionStackTrace = true));
#else
    var documentWriter = new DocumentWriter();
#endif
```

You can also write your own implementation of `IErrorInfoProvider`. For instance, you might want to override the numerical codes provided by the GraphQL framework for validation errors, or reveal stack traces only to logged-in administrators.

## Middleware

It is also possible to provide additional error handling or logging for fields by adding Field Middleware, but this is not recommended.
