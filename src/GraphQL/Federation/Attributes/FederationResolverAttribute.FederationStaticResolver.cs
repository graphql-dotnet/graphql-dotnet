using System.Collections;
using System.Diagnostics;
using System.Security.Claims;
using GraphQL.Execution;
using GraphQL.Federation.Resolvers;
using GraphQL.Instrumentation;
using GraphQL.Resolvers;
using GraphQL.Types;
using GraphQL.Validation;
using GraphQLParser.AST;

namespace GraphQL.Federation;

public partial class FederationResolverAttribute
{
    /// <summary>
    /// This federation resolver creates a <see cref="IResolveFieldContext"/> which has arguments matching
    /// the entity representation properties provided from Apollo Router, and a null source. It then calls
    /// the configured field resolver with the context. It is intended to be used for static federation
    /// resolvers in a type-first schema.
    /// </summary>
    /// <remarks>
    /// When the field is resolved, the type-first resolver will be called with the context, so when
    /// the resolver generated by <see cref="AutoRegisteringInputObjectGraphType"/> is called, it will
    /// pull the arguments (via <see cref="ResolveFieldContextExtensions.GetArgument{TType}(IResolveFieldContext, string, TType)"/>)
    /// from the entity representation properties. In this way all type-first attributes can be used with
    /// federation resolvers, such as <see cref="FromServicesAttribute"/>. Note that any input objects
    /// will be registered as input object graph types within the schema; mark them with
    /// <see cref="IGraphType.IsPrivate"/> to prevent them from being exposed.
    /// </remarks>
    private class FederationStaticResolver : IFederationResolver
    {
        private readonly FieldType _fieldType;

        public FederationStaticResolver(FieldType fieldType)
        {
            _fieldType = fieldType;
        }

        public Type SourceType => typeof(Dictionary<string, object?>);

        public object ParseRepresentation(IObjectGraphType graphType, IDictionary<string, object?> representation)
            => CreateArguments(_fieldType, representation)!;

        public ValueTask<object?> ResolveAsync(IResolveFieldContext context, IObjectGraphType graphType, object source)
        {
            var context2 = new Context(context, _fieldType, (Dictionary<string, ArgumentValue>?)source);
            var resolver = _fieldType.Resolver ?? ThrowForNoResolver();
            return resolver.ResolveAsync(context2);

            [DoesNotReturn]
            [StackTraceHidden]
            IFieldResolver ThrowForNoResolver()
                => throw new InvalidOperationException($"The field resolver for {_fieldType.Name} must be set on the field type.");
        }

        private Dictionary<string, ArgumentValue>? CreateArguments(FieldType fieldType, IDictionary<string, object?> representation)
        {
            if (fieldType.Arguments == null || fieldType.Arguments.Count <= 0)
            {
                return null;
            }

            var arguments = new Dictionary<string, ArgumentValue>();
            foreach (var arg in fieldType.Arguments)
            {
                var matched = representation.TryGetValue(arg.Name, out var value);
                if (matched)
                    value = Deserialize(arg.ResolvedType!, arg.Name, value);
                arguments[arg.Name] = matched
                    ? new ArgumentValue(value, ArgumentSource.Literal)
                    : new ArgumentValue(arg.DefaultValue, ArgumentSource.FieldDefault);
            }
            return arguments;
        }

        /// <summary>
        /// Deserializes an argument supplied within an entity representation from Apollo Router.
        /// Also see <see cref="ValidationContext.GetVariableValueAsync"/>.
        /// </summary>
        private static object? Deserialize(IGraphType type, string name, object? value)
        {
            // parse recursively based on the type of the graph type
            return ParseValue(type, name, value);

            static object? ParseValue(IGraphType type, VariableName name, object? value)
            {
                // validate non-null types and values first
                if (type is NonNullGraphType nonNullGraphType)
                {
                    return value == null
                        ? ThrowValueIsNullException(name)
                        : ParseValue(nonNullGraphType.ResolvedType!, name, value);
                }
                else if (value == null)
                    return null;

                // return a value based on the type of the graph type (scalar, input object, list)
                return type switch
                {
                    // scalar types simply parse the value
                    ScalarGraphType scalarGraphType => scalarGraphType.ParseValue(value),

                    // input object types need to parse each field first, then call ParseDictionary
                    IInputObjectGraphType inputObjectGraphType => value is IDictionary<string, object?> dic
                        ? ParseValueObject(inputObjectGraphType, name, dic)
                        : ThrowNotDictionaryException(name),

                    // list types need to parse each item in the list
                    ListGraphType listGraphType => value is IList list && value is not string
                        ? ParseValueList(listGraphType, name, list)
                        : new object?[] { ParseValue(listGraphType.ResolvedType!, name, value) },

                    // there should not be any other types remaining
                    _ => ThrowNotInputTypeException(name),
                };
            }

            // parse a list of values, returning an array of parsed objects
            static object? ParseValueList(ListGraphType listGraphType, VariableName name, IList list)
            {
                var itemType = listGraphType.ResolvedType!;
                var ret = new object?[list.Count];
                for (var i = 0; i < list.Count; i++)
                {
                    ret[i] = ParseValue(itemType, new(name, i), list[i]);
                }
                return ret;
            }

            // parse a dictionary of values, returning a parsed object
            static object? ParseValueObject(IInputObjectGraphType inputObjectGraphType, VariableName name, IDictionary<string, object?> dic)
            {
                bool anyNull = false;
                int fieldCount = 0;
                var ret = new Dictionary<string, object?>();
                foreach (var field in inputObjectGraphType.Fields)
                {
                    // if the field is present in the dictionary, parse the value
                    // if the field is not present, use the default value if it exists
                    // if the field is required and not present, throw an exception
                    var key = field.Name;
                    if (dic.TryGetValue(key, out var value))
                    {
                        ret[key] = ParseValue(field.ResolvedType!, new(name, key), value);
                        fieldCount += 1;
                        anyNull |= value == null;
                    }
                    else if (field.DefaultValue != null)
                    {
                        ret[key] = field.DefaultValue;
                    }
                    else if (field.ResolvedType is NonNullGraphType)
                    {
                        ThrowMissingFieldException(new(name, key));
                    }
                }

                // if the input object type is a one-of type, there must be exactly one field present
                if (inputObjectGraphType.IsOneOf && (fieldCount != 1 || anyNull))
                    ThrowOneOfException(name);

                // check for unmatched fields in the dictionary
                foreach (var key in dic.Keys)
                {
                    bool match = false;
                    foreach (var field in inputObjectGraphType.Fields)
                    {
                        if (key == field.Name)
                        {
                            match = true;
                            break;
                        }
                    }

                    if (!match)
                    {
                        ThrowExcessFieldException(name, key);
                    }
                }

                // parse the dictionary into a CLR object and return it
                return inputObjectGraphType.ParseDictionary(ret);
            }

            [StackTraceHidden]
            [DoesNotReturn]
            static object? ThrowValueIsNullException(VariableName name)
                => throw new InvalidOperationException($"The argument '{name}' must not be null.");

            [StackTraceHidden]
            [DoesNotReturn]
            static object? ThrowNotDictionaryException(VariableName name)
                => throw new InvalidOperationException($"The argument '{name}' must be a dictionary.");

            [StackTraceHidden]
            [DoesNotReturn]
            static object? ThrowNotInputTypeException(VariableName name)
                => throw new InvalidOperationException($"The argument '{name}' must be an input type.");

            [StackTraceHidden]
            [DoesNotReturn]
            static void ThrowMissingFieldException(VariableName name)
                => throw new InvalidOperationException($"The argument '{name}' is required but was not provided.");

            [StackTraceHidden]
            [DoesNotReturn]
            static void ThrowOneOfException(VariableName name)
                => throw new InvalidOperationException($"The argument '{name}' must have exactly one field present.");

            [StackTraceHidden]
            [DoesNotReturn]
            static void ThrowExcessFieldException(VariableName name, string field)
                => throw new InvalidOperationException($"The argument '{name}' has an excess field named {field}.");
        }

        private class Context : IResolveFieldContext
        {
            private readonly IResolveFieldContext _context;

            /// <summary>
            /// Initializes the context with <see cref="Arguments"/> for each field argument specified within
            /// <paramref name="fieldType"/>. The arguments are coerced from the entity representation properties
            /// supplied by <paramref name="arguments"/>.
            /// </summary>
            public Context(IResolveFieldContext context, FieldType fieldType, Dictionary<string, ArgumentValue>? arguments)
            {
                _context = context;
                FieldDefinition = fieldType;
                Arguments = arguments;
            }

            public GraphQLField FieldAst => _context.FieldAst;
            public FieldType FieldDefinition { get; }
            public IObjectGraphType ParentType => _context.ParentType;
            public IResolveFieldContext? Parent => _context.Parent;
            public IDictionary<string, ArgumentValue>? Arguments { get; }
            public IDictionary<string, DirectiveInfo>? Directives => _context.Directives;
            public object? RootValue => _context.RootValue;
            public object? Source => null;
            public ISchema Schema => _context.Schema;
            public GraphQLDocument Document => _context.Document;
            public GraphQLOperationDefinition Operation => _context.Operation;
            public Variables Variables => _context.Variables;
            public CancellationToken CancellationToken => _context.CancellationToken;
            public Metrics Metrics => _context.Metrics;
            public ExecutionErrors Errors => _context.Errors;
            public IEnumerable<object> Path => _context.Path;
            public IEnumerable<object> ResponsePath => _context.ResponsePath;
            public Dictionary<string, (GraphQLField Field, FieldType FieldType)>? SubFields => _context.SubFields;
            public IReadOnlyDictionary<string, object?> InputExtensions => _context.InputExtensions;
            public IDictionary<string, object?> OutputExtensions => _context.OutputExtensions;
            public IServiceProvider? RequestServices => _context.RequestServices;
            public IExecutionArrayPool ArrayPool => _context.ArrayPool;
            public ClaimsPrincipal? User => _context.User;
            public IDictionary<string, object?> UserContext => _context.UserContext;
        }
    }
}
