using System.Text;
using GraphQL.Analyzers.SourceGenerators.Models;

namespace GraphQL.Analyzers.SourceGenerators.Generators;

/// <summary>
/// Generates output graph type (object/interface) code for AOT scenarios.
/// </summary>
public static class OutputGraphTypeGenerator
{
    /// <summary>
    /// Generates the complete output graph type source code.
    /// </summary>
    /// <param name="namespace">The namespace for the generated class.</param>
    /// <param name="partialClassHierarchy">The hierarchy of partial classes.</param>
    /// <param name="outputGraphType">The output graph type data containing field and member information.</param>
    /// <returns>The generated source code as a string.</returns>
    public static string Generate(
        string? @namespace,
        ImmutableEquatableArray<PartialClassInfo> partialClassHierarchy,
        OutputGraphTypeData? outputGraphType)
    {
        if (outputGraphType == null || partialClassHierarchy.Count == 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(@namespace))
        {
            sb.AppendLine($"namespace {@namespace};");
            sb.AppendLine();
        }

        // Class declaration
        GenerateClassDeclaration(sb, partialClassHierarchy, outputGraphType);

        return sb.ToString();
    }

    private static void GenerateClassDeclaration(
        StringBuilder sb,
        ImmutableEquatableArray<PartialClassInfo> partialClassHierarchy,
        OutputGraphTypeData outputGraphType)
    {
        // Generate nested partial classes from outermost to innermost
        int indentLevel = 0;
        for (int i = 0; i < partialClassHierarchy.Count; i++)
        {
            var classInfo = partialClassHierarchy[i];
            var classAccessibility = classInfo.IsPublic ? "public" : "internal";

            sb.Append(new string(' ', indentLevel * 4));
            sb.AppendLine($"{classAccessibility} partial class {classInfo.ClassName}");
            sb.Append(new string(' ', indentLevel * 4));
            sb.AppendLine("{");
            indentLevel++;
        }

        // Generate the inner auto-registering graph type class
        GenerateAutoRegisteringGraphType(sb, indentLevel, outputGraphType);

        // Close all class declarations
        for (int i = partialClassHierarchy.Count - 1; i >= 0; i--)
        {
            indentLevel--;
            sb.Append(new string(' ', indentLevel * 4));
            sb.AppendLine("}");
        }
    }

    private static void GenerateAutoRegisteringGraphType(
        StringBuilder sb,
        int indentLevel,
        OutputGraphTypeData outputGraphType)
    {
        var indent = new string(' ', indentLevel * 4);
        var baseType = outputGraphType.IsInterface
            ? $"global::GraphQL.Types.Aot.AotAutoRegisteringInterfaceGraphType<{outputGraphType.FullyQualifiedClrTypeName}>"
            : $"global::GraphQL.Types.Aot.AotAutoRegisteringObjectGraphType<{outputGraphType.FullyQualifiedClrTypeName}>";

        // Class declaration
        sb.AppendLine($"{indent}private class {outputGraphType.GraphTypeClassName} : {baseType}");
        sb.AppendLine($"{indent}{{");

        // Generate members dictionary field
        GenerateMembersDictionaryField(sb, indentLevel + 1, outputGraphType);

        // Generate constructor
        GenerateConstructor(sb, indentLevel + 1, outputGraphType);

        // Generate GetRegisteredMembers method
        GenerateGetRegisteredMembersMethod(sb, indentLevel + 1);

        // Generate BuildFieldType method
        GenerateBuildFieldTypeMethod(sb, indentLevel + 1, outputGraphType);

        // Generate ConstructField methods for object types
        GenerateConstructFieldMethods(sb, indentLevel + 1, outputGraphType);

        sb.AppendLine($"{indent}}}");
    }

    private static void GenerateMembersDictionaryField(
        StringBuilder sb,
        int indentLevel,
        OutputGraphTypeData outputGraphType)
    {
        var indent = new string(' ', indentLevel * 4);
        var actionType = outputGraphType.IsInterface
            ? "global::System.Action<global::GraphQL.Types.FieldType, global::System.Reflection.MemberInfo>?"
            : "global::System.Action<global::GraphQL.Types.FieldType, global::System.Reflection.MemberInfo>";

        sb.AppendLine($"{indent}private readonly global::System.Collections.Generic.Dictionary<global::System.Reflection.MemberInfo, {actionType}> _members;");
    }

    private static void GenerateConstructor(
        StringBuilder sb,
        int indentLevel,
        OutputGraphTypeData outputGraphType)
    {
        var indent = new string(' ', indentLevel * 4);

        sb.AppendLine($"{indent}public {outputGraphType.GraphTypeClassName}()");
        sb.AppendLine($"{indent}{{");

        // Initialize _members dictionary
        sb.AppendLine($"{indent}    _members = new()");
        sb.AppendLine($"{indent}    {{");

        foreach (var member in outputGraphType.SelectedMembers)
        {
            GenerateMemberDictionaryEntry(sb, indentLevel + 2, member, outputGraphType);
        }

        sb.AppendLine($"{indent}    }};");

        // Add fields
        sb.AppendLine($"{indent}    foreach (var fieldType in ProvideFields())");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        AddField(fieldType);");
        sb.AppendLine($"{indent}    }}");

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private static void GenerateMemberDictionaryEntry(
        StringBuilder sb,
        int indentLevel,
        OutputMemberData member,
        OutputGraphTypeData outputGraphType)
    {
        var indent = new string(' ', indentLevel * 4);
        var declaringType = member.DeclaringTypeFullyQualifiedName ?? outputGraphType.FullyQualifiedClrTypeName;

        string memberAccessExpression;
        if (member.MemberKind == MemberKind.Method)
        {
            // For methods, include parameter types - all fully qualified
            var paramTypes = string.Join(", ", member.MethodParameters.Select(p => $"typeof({p.FullyQualifiedTypeName})"));
            memberAccessExpression = $"typeof({declaringType}).GetMethod(nameof({declaringType}.{member.MemberName}), [{paramTypes}])!";
        }
        else
        {
            // For properties and fields - all fully qualified
            var memberTypeString = member.MemberKind == MemberKind.Property ? "GetProperty" : "GetField";
            memberAccessExpression = $"typeof({declaringType}).{memberTypeString}(nameof({declaringType}.{member.MemberName}))!";
        }

        var actionValue = outputGraphType.IsInterface && !member.IsStatic ? "null" : $"ConstructField_{member.MemberName}";

        sb.AppendLine($"{indent}{{ {memberAccessExpression}, {actionValue} }},");
    }

    private static void GenerateGetRegisteredMembersMethod(
        StringBuilder sb,
        int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);

        sb.AppendLine($"{indent}protected override global::System.Collections.Generic.IEnumerable<global::System.Reflection.MemberInfo> GetRegisteredMembers() => _members.Keys;");
    }

    private static void GenerateBuildFieldTypeMethod(
        StringBuilder sb,
        int indentLevel,
        OutputGraphTypeData outputGraphType)
    {
        var indent = new string(' ', indentLevel * 4);

        sb.AppendLine($"{indent}protected override void BuildFieldType(global::GraphQL.Types.FieldType fieldType, global::System.Reflection.MemberInfo memberInfo)");
        sb.AppendLine($"{indent}{{");

        if (outputGraphType.IsInterface)
        {
            sb.AppendLine($"{indent}    _members[memberInfo]?.Invoke(fieldType, memberInfo);");
            sb.AppendLine($"{indent}    if (!fieldType.IsPrivate)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        fieldType.Resolver = null;");
            sb.AppendLine($"{indent}        fieldType.StreamResolver = null;");
            sb.AppendLine($"{indent}    }}");
        }
        else
        {
            sb.AppendLine($"{indent}    _members[memberInfo](fieldType, memberInfo);");
        }

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private static void GenerateConstructFieldMethods(
        StringBuilder sb,
        int indentLevel,
        OutputGraphTypeData outputGraphType)
    {
        var indent = new string(' ', indentLevel * 4);

        foreach (var member in outputGraphType.SelectedMembers)
        {
            if (!member.IsStatic && outputGraphType.IsInterface)
            {
                // Skip instance members for interfaces
                continue;
            }

            sb.AppendLine($"{indent}public void ConstructField_{member.MemberName}(global::GraphQL.Types.FieldType fieldType, global::System.Reflection.MemberInfo memberInfo)");
            sb.AppendLine($"{indent}{{");

            if (member.MemberKind == MemberKind.Method)
            {
                GenerateMethodResolver(sb, indentLevel + 1, member, outputGraphType);
            }
            else
            {
                GeneratePropertyOrFieldResolver(sb, indentLevel + 1, member, outputGraphType);
            }

            sb.AppendLine($"{indent}}}");
            sb.AppendLine();
        }
    }

    private static void GenerateMethodResolver(
        StringBuilder sb,
        int indentLevel,
        OutputMemberData member,
        OutputGraphTypeData outputGraphType)
    {
        var indent = new string(' ', indentLevel * 4);

        if (member.MethodParameters.Count > 0)
        {
            // Declare method parameters
            sb.AppendLine($"{indent}var parameters = ((global::System.Reflection.MethodInfo)memberInfo).GetParameters();");

            for (int i = 0; i < member.MethodParameters.Count; i++)
            {
                var param = member.MethodParameters[i];
                // Use fully qualified type name
                sb.AppendLine($"{indent}var param{i} = BuildArgument<{param.FullyQualifiedTypeName}>(fieldType, parameters[{i}]);");
            }
        }

        // Build resolver
        sb.AppendLine($"{indent}fieldType.Resolver = BuildFieldResolver(context =>");
        sb.AppendLine($"{indent}{{");

        if (member.IsStatic)
        {
            // Static method call - use fully qualified type name
            var declaringType = member.DeclaringTypeFullyQualifiedName ?? outputGraphType.FullyQualifiedClrTypeName;

            if (member.MethodParameters.Count > 0)
            {
                // Build argument list
                for (int i = 0; i < member.MethodParameters.Count; i++)
                {
                    sb.AppendLine($"{indent}    var arg{i} = param{i}(context);");
                }
                var args = string.Join(", ", Enumerable.Range(0, member.MethodParameters.Count).Select(i => $"arg{i}"));
                sb.AppendLine($"{indent}    return {declaringType}.{member.MemberName}({args});");
            }
            else
            {
                sb.AppendLine($"{indent}    return {declaringType}.{member.MemberName}();");
            }
        }
        else
        {
            // Instance method call
            sb.AppendLine($"{indent}    var source = GetMemberInstance(context);");

            if (member.MethodParameters.Count > 0)
            {
                // Build argument list
                for (int i = 0; i < member.MethodParameters.Count; i++)
                {
                    sb.AppendLine($"{indent}    var arg{i} = param{i}(context);");
                }
                var args = string.Join(", ", Enumerable.Range(0, member.MethodParameters.Count).Select(i => $"arg{i}"));
                sb.AppendLine($"{indent}    return source.{member.MemberName}({args});");
            }
            else
            {
                sb.AppendLine($"{indent}    return source.{member.MemberName}();");
            }
        }

        sb.AppendLine($"{indent}}}, true);");
    }

    private static void GeneratePropertyOrFieldResolver(
        StringBuilder sb,
        int indentLevel,
        OutputMemberData member,
        OutputGraphTypeData outputGraphType)
    {
        var indent = new string(' ', indentLevel * 4);

        if (member.IsStatic)
        {
            // Static property/field access - use fully qualified type name
            var declaringType = member.DeclaringTypeFullyQualifiedName ?? outputGraphType.FullyQualifiedClrTypeName;
            sb.AppendLine($"{indent}fieldType.Resolver = BuildFieldResolver(context => {declaringType}.{member.MemberName}, false);");
        }
        else
        {
            // Instance property/field access
            sb.AppendLine($"{indent}fieldType.Resolver = BuildFieldResolver(context => GetMemberInstance(context).{member.MemberName}, false);");
        }
    }
}
