using GraphQL.Analyzers.SourceGenerators.Models;

namespace GraphQL.Analyzers.SourceGenerators.Generators;

/// <summary>
/// Generates schema configuration code for AOT scenarios.
/// </summary>
public static class SchemaConfigurationGenerator
{
    /// <summary>
    /// Generates the complete schema configuration source code.
    /// </summary>
    /// <param name="namespace">The namespace for the generated class.</param>
    /// <param name="partialClassHierarchy">The hierarchy of partial classes.</param>
    /// <param name="schemaClass">The schema class data containing registration information.</param>
    /// <returns>The generated source code as a string.</returns>
    public static string Generate(
        string? @namespace,
        ImmutableEquatableArray<PartialClassInfo> partialClassHierarchy,
        SchemaClassData? schemaClass)
    {
        if (schemaClass == null || partialClassHierarchy.Count == 0)
        {
            return string.Empty;
        }

        var sb = new SourceBuilder();

        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(@namespace))
        {
            sb.AppendLine($"namespace {@namespace};");
            sb.AppendLine();
        }

        // Class declaration
        GenerateClassDeclaration(sb, partialClassHierarchy, schemaClass);

        return sb.ToString();
    }

    private static void GenerateClassDeclaration(
        SourceBuilder sb,
        ImmutableEquatableArray<PartialClassInfo> partialClassHierarchy,
        SchemaClassData schemaClass)
    {
        var rootClass = partialClassHierarchy[partialClassHierarchy.Count - 1];
        var hasListTypes = HasListTypes(schemaClass);

        // Generate nested partial classes from outermost to innermost
        for (int i = 0; i < partialClassHierarchy.Count; i++)
        {
            var classInfo = partialClassHierarchy[i];
            var classAccessibility = classInfo.Accessibility switch
            {
                ClassAccessibility.Public => "public",
                ClassAccessibility.Private => "private",
                _ => "internal"
            };

            sb.Append($"{classAccessibility} partial class {classInfo.ClassName}");

            // Add interface implementation only on the innermost class and only if there are list types
            if (i == partialClassHierarchy.Count - 1 && hasListTypes)
            {
                sb.AppendLine(" : global::GraphQL.Conversion.IListConverterFactory");
            }
            else
            {
                sb.AppendLine();
            }

            sb.AppendLine("{");
            sb.Indentation++;
        }

        // Generate constructor if needed
        if (!schemaClass.HasConstructor)
        {
            GenerateConstructor(sb, rootClass.ClassName);
        }

        // Generate Configure method
        GenerateConfigureMethod(sb, schemaClass);

        // Generate list converter infrastructure only if there are list types
        if (hasListTypes)
        {
            GenerateListConverterInfrastructure(sb);
        }

        // Close all class declarations
        for (int i = partialClassHierarchy.Count - 1; i >= 0; i--)
        {
            sb.Indentation--;
            sb.AppendLine("}");
        }
    }

    private static bool HasListTypes(SchemaClassData schemaClass)
    {
        return schemaClass.ArrayListTypes.Count > 0
            || schemaClass.GenericListTypes.Count > 0
            || schemaClass.HashSetTypes.Count > 0;
    }

    private static void GenerateConstructor(SourceBuilder sb, string className)
    {
        sb.AppendLine("[global::GraphQL.GraphQLConstructor]");
        sb.AppendLine($"public {className}(global::System.IServiceProvider services, global::System.Collections.Generic.IEnumerable<global::GraphQL.DI.IConfigureSchema> configurations) : base(services, configurations)");
        sb.AppendLine("{");
        using (sb.Indent())
        {
            sb.AppendLine("Configure();");
        }
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void GenerateConfigureMethod(SourceBuilder sb, SchemaClassData schemaClass)
    {
        sb.AppendLine("protected override void Configure()");
        sb.AppendLine("{");

        using (sb.Indent())
        {
            // Generate AddAotType calls
            foreach (var registeredType in schemaClass.RegisteredGraphTypes)
            {
                // Use standard AddAotType if there's an AOT-generated type name
                if (!string.IsNullOrEmpty(registeredType.AotGeneratedTypeName))
                {
                    sb.AppendLine($"AddAotType<{registeredType.FullyQualifiedGraphTypeName}, {registeredType.AotGeneratedTypeName}>();");
                }
                // Use standard AddAotType if constructor data indicates zero parameters and zero required properties
                else if (registeredType.ConstructorData != null
                    && registeredType.ConstructorData.Parameters.Count == 0
                    && registeredType.ConstructorData.RequiredProperties.Count == 0)
                {
                    sb.Append($"AddAotType<{registeredType.FullyQualifiedGraphTypeName}");
                    if (!string.IsNullOrEmpty(registeredType.OverrideTypeName))
                    {
                        sb.Append($", {registeredType.OverrideTypeName}");
                    }
                    sb.AppendLine(">();");
                }
                // Skip if constructor data is null
                else if (registeredType.ConstructorData == null)
                {
                    // Do not generate AddAotType line; user must register the type manually within their DI setup
                }
                // Generate factory lambda for types with constructor parameters or required properties
                else
                {
                    var targetTypeName = registeredType.OverrideTypeName ?? registeredType.FullyQualifiedGraphTypeName;
                    sb.Append($"AotTypes.Add(typeof({registeredType.FullyQualifiedGraphTypeName}), () => new {targetTypeName}(");

                    // Generate constructor parameters
                    bool firstParam = true;
                    foreach (var param in registeredType.ConstructorData.Parameters)
                    {
                        if (!firstParam)
                            sb.Append(", ");
                        firstParam = false;

                        var paramTypeName = param.FullyQualifiedTypeName ?? "global::GraphQL.IResolveFieldContext";
                        sb.Append($"GetRequiredService<{paramTypeName}>()");
                    }

                    sb.Append(")");

                    // Generate required properties initialization
                    if (registeredType.ConstructorData.RequiredProperties.Count > 0)
                    {
                        sb.AppendLine();
                        sb.AppendLine("{");

                        using (sb.Indent())
                        {
                            foreach (var prop in registeredType.ConstructorData.RequiredProperties)
                            {
                                sb.AppendLine($"{prop.Name} = GetRequiredService<{prop.FullyQualifiedTypeName}>(),");
                            }
                        }

                        sb.Append("}");
                    }

                    sb.AppendLine(");");
                }
            }

            if (schemaClass.RegisteredGraphTypes.Count > 0)
                sb.AppendLine();

            // Generate RegisterType calls
            foreach (var registeredType in schemaClass.RegisteredGraphTypes)
            {
                sb.AppendLine($"RegisterType(typeof({registeredType.FullyQualifiedGraphTypeName}));");
            }

            if (schemaClass.RegisteredGraphTypes.Count > 0)
                sb.AppendLine();

            // Generate RegisterTypeMapping calls
            foreach (var typeMapping in schemaClass.TypeMappings)
            {
                sb.AppendLine($"RegisterTypeMapping(typeof({typeMapping.FullyQualifiedClrTypeName}), typeof({typeMapping.FullyQualifiedGraphTypeName}));");
            }

            if (schemaClass.TypeMappings.Count > 0)
                sb.AppendLine();

            // Configure root types
            if (!string.IsNullOrEmpty(schemaClass.QueryRootTypeName))
            {
                sb.AppendLine($"Query = GetRequiredService<{schemaClass.QueryRootTypeName}>();");
            }
            if (!string.IsNullOrEmpty(schemaClass.MutationRootTypeName))
            {
                sb.AppendLine($"Mutation = GetRequiredService<{schemaClass.MutationRootTypeName}>();");
            }
            if (!string.IsNullOrEmpty(schemaClass.SubscriptionRootTypeName))
            {
                sb.AppendLine($"Subscription = GetRequiredService<{schemaClass.SubscriptionRootTypeName}>();");
            }

            if (!string.IsNullOrEmpty(schemaClass.QueryRootTypeName)
                || !string.IsNullOrEmpty(schemaClass.MutationRootTypeName)
                || !string.IsNullOrEmpty(schemaClass.SubscriptionRootTypeName))
            {
                sb.AppendLine();
            }

            // Generate list converter registrations only if there are list types
            if (HasListTypes(schemaClass))
            {
                GenerateListConverterRegistrations(sb, schemaClass);

                sb.AppendLine("foreach (var listType in _listConverters.Keys)");
                sb.AppendLine("{");
                using (sb.Indent())
                {
                    sb.AppendLine("ValueConverter.RegisterListConverterFactory(listType, this);");
                }
                sb.AppendLine("}");
            }
        }

        sb.AppendLine("}");
    }

    private static void GenerateListConverterRegistrations(SourceBuilder sb, SchemaClassData schemaClass)
    {
        // Generate array list type converters
        foreach (var arrayTypeData in schemaClass.ArrayListTypes)
        {
            sb.AppendLine("{");

            using (sb.Indent())
            {
                var elementType = arrayTypeData.ElementTypeName;
                var defaultValue = arrayTypeData.IsNullable ? ")value" : "?)value ?? default";

                sb.AppendLine($"var converter = new global::GraphQL.Conversion.ListConverter(typeof({elementType}), values => global::System.Array.ConvertAll(values, value => ({elementType}{defaultValue}));");
                sb.AppendLine($"_listConverters[typeof({elementType}[])] = converter;");

                // Add related generic list types
                sb.AppendLine($"_listConverters[typeof(global::System.Collections.Generic.IEnumerable<{elementType}>)] = converter;");
                sb.AppendLine($"_listConverters[typeof(global::System.Collections.Generic.IList<{elementType}>)] = converter;");
                sb.AppendLine($"_listConverters[typeof(global::System.Collections.Generic.ICollection<{elementType}>)] = converter;");
                sb.AppendLine($"_listConverters[typeof(global::System.Collections.Generic.IReadOnlyCollection<{elementType}>)] = converter;");
                sb.AppendLine($"_listConverters[typeof(global::System.Collections.Generic.IReadOnlyList<{elementType}>)] = converter;");
            }

            sb.AppendLine("}");
        }

        // Generate generic list type converters
        foreach (var genericListTypeData in schemaClass.GenericListTypes)
        {
            var elementType = genericListTypeData.ElementTypeName;
            var defaultValue = genericListTypeData.IsNullable ? ")value" : "?)value ?? default";

            sb.AppendLine($"_listConverters[typeof(global::System.Collections.Generic.List<{elementType}>)] = new global::GraphQL.Conversion.ListConverter(typeof({elementType}), values => global::System.Array.ConvertAll(values, value => ({elementType}{defaultValue}));");
        }

        // Generate HashSet type converters
        foreach (var hashSetTypeData in schemaClass.HashSetTypes)
        {
            sb.AppendLine("{");

            using (sb.Indent())
            {
                var elementType = hashSetTypeData.ElementTypeName;
                var defaultValue = hashSetTypeData.IsNullable ? ")value" : "?)value ?? default";

                sb.AppendLine($"var converter = new global::GraphQL.Conversion.ListConverter(typeof({elementType}), values => global::System.Array.ConvertAll(values, value => ({elementType}{defaultValue}));");
                sb.AppendLine($"_listConverters[typeof(global::System.Collections.Generic.HashSet<{elementType}>)] = converter;");
                sb.AppendLine($"_listConverters[typeof(global::System.Collections.Generic.ISet<{elementType}>)] = converter;");
            }

            sb.AppendLine("}");
        }

        if (schemaClass.ArrayListTypes.Count > 0 || schemaClass.GenericListTypes.Count > 0 || schemaClass.HashSetTypes.Count > 0)
        {
            sb.AppendLine();
        }
    }

    private static void GenerateListConverterInfrastructure(SourceBuilder sb)
    {
        sb.AppendLine();
        sb.AppendLine("private readonly global::System.Collections.Generic.Dictionary<global::System.Type, global::GraphQL.Conversion.IListConverter> _listConverters = new();");
        sb.AppendLine();
        sb.AppendLine("public global::GraphQL.Conversion.IListConverter Create(global::System.Type listType)");
        sb.AppendLine("{");
        using (sb.Indent())
        {
            sb.AppendLine("return _listConverters[listType];");
        }
        sb.AppendLine("}");
    }
}
