using System.Text;
using GraphQL.Analyzers.SourceGenerators.Models;

namespace GraphQL.Analyzers.SourceGenerators.Generators;

/// <summary>
/// Generates schema configuration code for AOT scenarios.
/// </summary>
public static class SchemaConfigurationGenerator
{
    /// <summary>
    /// Generates the complete schema configuration source code.
    /// </summary>
    /// <param name="namespace">The namespace for the generated class.</param>
    /// <param name="partialClassHierarchy">The hierarchy of partial classes.</param>
    /// <param name="schemaClass">The schema class data containing registration information.</param>
    /// <returns>The generated source code as a string.</returns>
    public static string Generate(
        string? @namespace,
        ImmutableEquatableArray<PartialClassInfo> partialClassHierarchy,
        SchemaClassData? schemaClass)
    {
        if (schemaClass == null || partialClassHierarchy.Count == 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(@namespace))
        {
            sb.AppendLine($"namespace {@namespace};");
            sb.AppendLine();
        }

        // Class declaration
        GenerateClassDeclaration(sb, partialClassHierarchy, schemaClass);

        return sb.ToString();
    }

    private static void GenerateClassDeclaration(
        StringBuilder sb,
        ImmutableEquatableArray<PartialClassInfo> partialClassHierarchy,
        SchemaClassData schemaClass)
    {
        var rootClass = partialClassHierarchy[partialClassHierarchy.Count - 1];
        var hasListTypes = HasListTypes(schemaClass);

        // Generate nested partial classes from outermost to innermost
        int indentLevel = 0;
        for (int i = 0; i < partialClassHierarchy.Count; i++)
        {
            var classInfo = partialClassHierarchy[i];
            var classAccessibility = classInfo.Accessibility switch
            {
                ClassAccessibility.Public => "public",
                ClassAccessibility.Private => "private",
                _ => "internal"
            };

            sb.Append(new string(' ', indentLevel * 4));
            sb.Append($"{classAccessibility} partial class {classInfo.ClassName}");

            // Add interface implementation only on the innermost class and only if there are list types
            if (i == partialClassHierarchy.Count - 1 && hasListTypes)
            {
                sb.AppendLine(" : global::GraphQL.Conversion.IListConverterFactory");
            }
            else
            {
                sb.AppendLine();
            }

            sb.Append(new string(' ', indentLevel * 4));
            sb.AppendLine("{");
            indentLevel++;
        }

        // Generate constructor if needed
        if (!schemaClass.HasConstructor)
        {
            GenerateConstructor(sb, indentLevel, rootClass.ClassName);
        }

        // Generate Configure method
        GenerateConfigureMethod(sb, indentLevel, schemaClass);

        // Generate list converter infrastructure only if there are list types
        if (hasListTypes)
        {
            GenerateListConverterInfrastructure(sb, indentLevel);
        }

        // Close all class declarations
        for (int i = partialClassHierarchy.Count - 1; i >= 0; i--)
        {
            indentLevel--;
            sb.Append(new string(' ', indentLevel * 4));
            sb.AppendLine("}");
        }
    }

    private static bool HasListTypes(SchemaClassData schemaClass)
    {
        return schemaClass.ArrayListTypes.Count > 0
            || schemaClass.GenericListTypes.Count > 0
            || schemaClass.HashSetTypes.Count > 0;
    }

    private static void GenerateConstructor(StringBuilder sb, int indentLevel, string className)
    {
        var indent = new string(' ', indentLevel * 4);

        sb.AppendLine($"{indent}[global::GraphQL.GraphQLConstructor]");
        sb.AppendLine($"{indent}public {className}(global::System.IServiceProvider services, global::System.Collections.Generic.IEnumerable<global::GraphQL.DI.IConfigureSchema> configurations) : base(services, configurations)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    Configure();");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private static void GenerateConfigureMethod(StringBuilder sb, int indentLevel, SchemaClassData schemaClass)
    {
        var indent = new string(' ', indentLevel * 4);

        sb.AppendLine($"{indent}private void Configure()");
        sb.AppendLine($"{indent}{{");

        // Generate AddAotType calls
        foreach (var registeredType in schemaClass.RegisteredGraphTypes)
        {
            // Use standard AddAotType if there's an AOT-generated type name
            if (!string.IsNullOrEmpty(registeredType.AotGeneratedTypeName))
            {
                sb.AppendLine($"{indent}    AddAotType<{registeredType.FullyQualifiedGraphTypeName}, {registeredType.AotGeneratedTypeName}>();");
            }
            // Use standard AddAotType if constructor data indicates zero parameters and zero required properties
            else if (registeredType.ConstructorData != null
                && registeredType.ConstructorData.Parameters.Count == 0
                && registeredType.ConstructorData.RequiredProperties.Count == 0)
            {
                sb.Append($"{indent}    AddAotType<{registeredType.FullyQualifiedGraphTypeName}");
                if (!string.IsNullOrEmpty(registeredType.OverrideTypeName))
                {
                    sb.Append($", {registeredType.OverrideTypeName}");
                }
                sb.AppendLine(">();");
            }
            // Skip if constructor data is null
            else if (registeredType.ConstructorData == null)
            {
                // Do not generate AddAotType line; user must register the type manually within their DI setup
            }
            // Generate factory lambda for types with constructor parameters or required properties
            else
            {
                var targetTypeName = registeredType.OverrideTypeName ?? registeredType.FullyQualifiedGraphTypeName;
                sb.Append($"{indent}    AotTypes.Add(typeof({registeredType.FullyQualifiedGraphTypeName}), () => new {targetTypeName}(");

                // Generate constructor parameters
                bool firstParam = true;
                foreach (var param in registeredType.ConstructorData.Parameters)
                {
                    if (!firstParam)
                        sb.Append(", ");
                    firstParam = false;

                    var paramTypeName = param.FullyQualifiedTypeName ?? "global::GraphQL.IResolveFieldContext";
                    sb.Append($"GetRequiredService<{paramTypeName}>()");
                }

                sb.Append(")");

                // Generate required properties initialization
                if (registeredType.ConstructorData.RequiredProperties.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine($"{indent}    {{");

                    foreach (var prop in registeredType.ConstructorData.RequiredProperties)
                    {
                        sb.AppendLine($"{indent}        {prop.Name} = GetRequiredService<{prop.FullyQualifiedTypeName}>(),");
                    }

                    sb.Append($"{indent}    }}");
                }

                sb.AppendLine(");");
            }
        }

        if (schemaClass.RegisteredGraphTypes.Count > 0)
            sb.AppendLine();

        // Generate RegisterType calls
        foreach (var registeredType in schemaClass.RegisteredGraphTypes)
        {
            sb.AppendLine($"{indent}    RegisterType(typeof({registeredType.FullyQualifiedGraphTypeName}));");
        }

        if (schemaClass.RegisteredGraphTypes.Count > 0)
            sb.AppendLine();

        // Generate RegisterTypeMapping calls
        foreach (var typeMapping in schemaClass.TypeMappings)
        {
            sb.AppendLine($"{indent}    RegisterTypeMapping(typeof({typeMapping.FullyQualifiedClrTypeName}), typeof({typeMapping.FullyQualifiedGraphTypeName}));");
        }

        if (schemaClass.TypeMappings.Count > 0)
            sb.AppendLine();

        // Configure root types
        if (!string.IsNullOrEmpty(schemaClass.QueryRootTypeName))
        {
            sb.AppendLine($"{indent}    Query = GetRequiredService<{schemaClass.QueryRootTypeName}>();");
        }
        if (!string.IsNullOrEmpty(schemaClass.MutationRootTypeName))
        {
            sb.AppendLine($"{indent}    Mutation = GetRequiredService<{schemaClass.MutationRootTypeName}>();");
        }
        if (!string.IsNullOrEmpty(schemaClass.SubscriptionRootTypeName))
        {
            sb.AppendLine($"{indent}    Subscription = GetRequiredService<{schemaClass.SubscriptionRootTypeName}>();");
        }

        if (!string.IsNullOrEmpty(schemaClass.QueryRootTypeName)
            || !string.IsNullOrEmpty(schemaClass.MutationRootTypeName)
            || !string.IsNullOrEmpty(schemaClass.SubscriptionRootTypeName))
        {
            sb.AppendLine();
        }

        // Generate list converter registrations only if there are list types
        if (HasListTypes(schemaClass))
        {
            GenerateListConverterRegistrations(sb, indentLevel, schemaClass);

            sb.AppendLine($"{indent}    foreach (var listType in _listConverters.Keys)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        ValueConverter.RegisterListConverterFactory(listType, this);");
            sb.AppendLine($"{indent}    }}");
        }

        sb.AppendLine($"{indent}}}");
    }

    private static void GenerateListConverterRegistrations(StringBuilder sb, int indentLevel, SchemaClassData schemaClass)
    {
        var indent = new string(' ', indentLevel * 4);

        // Generate array list type converters
        foreach (var arrayTypeData in schemaClass.ArrayListTypes)
        {
            sb.AppendLine($"{indent}    {{");

            var elementType = arrayTypeData.ElementTypeName;
            var defaultValue = arrayTypeData.IsNullable ? ")value" : "?)value ?? default";

            sb.AppendLine($"{indent}        var converter = new global::GraphQL.Conversion.ListConverter(typeof({elementType}), values => global::System.Array.ConvertAll(values, value => ({elementType}{defaultValue}));");
            sb.AppendLine($"{indent}        _listConverters[typeof({elementType}[])] = converter;");

            // Add related generic list types
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.IEnumerable<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.IList<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.ICollection<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.IReadOnlyCollection<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.IReadOnlyList<{elementType}>)] = converter;");

            sb.AppendLine($"{indent}    }}");
        }

        // Generate generic list type converters
        foreach (var genericListTypeData in schemaClass.GenericListTypes)
        {
            var elementType = genericListTypeData.ElementTypeName;
            var defaultValue = genericListTypeData.IsNullable ? ")value" : "?)value ?? default";

            sb.AppendLine($"{indent}    _listConverters[typeof(global::System.Collections.Generic.List<{elementType}>)] = new global::GraphQL.Conversion.ListConverter(typeof({elementType}), values => global::System.Array.ConvertAll(values, value => ({elementType}{defaultValue}));");
        }

        // Generate HashSet type converters
        foreach (var hashSetTypeData in schemaClass.HashSetTypes)
        {
            sb.AppendLine($"{indent}    {{");

            var elementType = hashSetTypeData.ElementTypeName;
            var defaultValue = hashSetTypeData.IsNullable ? ")value" : "?)value ?? default";

            sb.AppendLine($"{indent}        var converter = new global::GraphQL.Conversion.ListConverter(typeof({elementType}), values => global::System.Array.ConvertAll(values, value => ({elementType}{defaultValue}));");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.HashSet<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.ISet<{elementType}>)] = converter;");

            sb.AppendLine($"{indent}    }}");
        }

        if (schemaClass.ArrayListTypes.Count > 0 || schemaClass.GenericListTypes.Count > 0 || schemaClass.HashSetTypes.Count > 0)
        {
            sb.AppendLine();
        }
    }

    private static void GenerateListConverterInfrastructure(StringBuilder sb, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);

        sb.AppendLine();
        sb.AppendLine($"{indent}private readonly global::System.Collections.Generic.Dictionary<global::System.Type, global::GraphQL.Conversion.IListConverter> _listConverters = new();");
        sb.AppendLine();
        sb.AppendLine($"{indent}public global::GraphQL.Conversion.IListConverter Create(global::System.Type listType)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    return _listConverters[listType];");
        sb.AppendLine($"{indent}}}");
    }
}
