using System.Text;
using GraphQL.Analyzers.SourceGenerators.Models;

namespace GraphQL.Analyzers.SourceGenerators.Generators;

/// <summary>
/// Generates schema configuration code for AOT scenarios.
/// </summary>
public static class SchemaConfigurationGenerator
{
    /// <summary>
    /// Generates the complete schema configuration source code.
    /// </summary>
    /// <param name="namespace">The namespace for the generated class.</param>
    /// <param name="partialClassHierarchy">The hierarchy of partial classes.</param>
    /// <param name="schemaClass">The schema class data containing registration information.</param>
    /// <returns>The generated source code as a string.</returns>
    public static string Generate(
        string? @namespace,
        ImmutableEquatableArray<PartialClassInfo> partialClassHierarchy,
        SchemaClassData? schemaClass)
    {
        if (schemaClass == null || partialClassHierarchy.Count == 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Namespace
        if (!string.IsNullOrEmpty(@namespace))
        {
            sb.AppendLine($"namespace {@namespace};");
            sb.AppendLine();
        }

        // Class declaration
        GenerateClassDeclaration(sb, partialClassHierarchy, schemaClass);

        return sb.ToString();
    }

    private static void GenerateClassDeclaration(
        StringBuilder sb,
        ImmutableEquatableArray<PartialClassInfo> partialClassHierarchy,
        SchemaClassData schemaClass)
    {
        var rootClass = partialClassHierarchy[partialClassHierarchy.Count - 1];

        // Generate nested partial classes from outermost to innermost
        int indentLevel = 0;
        for (int i = 0; i < partialClassHierarchy.Count; i++)
        {
            var classInfo = partialClassHierarchy[i];
            var classAccessibility = classInfo.IsPublic ? "public" : "internal";

            sb.Append(new string(' ', indentLevel * 4));
            sb.Append($"{classAccessibility} partial class {classInfo.ClassName}");

            // Add interface implementation only on the innermost class
            if (i == partialClassHierarchy.Count - 1)
            {
                sb.AppendLine(" : global::GraphQL.Conversion.IListConverterFactory");
            }
            else
            {
                sb.AppendLine();
            }

            sb.Append(new string(' ', indentLevel * 4));
            sb.AppendLine("{");
            indentLevel++;
        }

        // Generate constructor if needed
        if (!schemaClass.HasConstructor)
        {
            GenerateConstructor(sb, indentLevel, rootClass.ClassName);
        }

        // Generate Configure method
        GenerateConfigureMethod(sb, indentLevel, schemaClass);

        // Generate list converter infrastructure
        GenerateListConverterInfrastructure(sb, indentLevel);

        // Close all class declarations
        for (int i = partialClassHierarchy.Count - 1; i >= 0; i--)
        {
            indentLevel--;
            sb.Append(new string(' ', indentLevel * 4));
            sb.AppendLine("}");
        }
    }

    private static void GenerateConstructor(StringBuilder sb, int indentLevel, string className)
    {
        var indent = new string(' ', indentLevel * 4);

        sb.AppendLine($"{indent}public {className}(global::System.IServiceProvider services, global::System.Collections.Generic.IEnumerable<global::GraphQL.DI.IConfigureSchema> configurations) : base(services, configurations)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    Configure();");
        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private static void GenerateConfigureMethod(StringBuilder sb, int indentLevel, SchemaClassData schemaClass)
    {
        var indent = new string(' ', indentLevel * 4);

        sb.AppendLine($"{indent}private void Configure()");
        sb.AppendLine($"{indent}{{");

        // Generate AddAotType calls
        foreach (var registeredType in schemaClass.RegisteredGraphTypes)
        {
            sb.Append($"{indent}    AddAotType<{registeredType.FullyQualifiedGraphTypeName}");
            if (!string.IsNullOrEmpty(registeredType.AotGeneratedTypeName))
            {
                sb.Append($", {registeredType.AotGeneratedTypeName}");
            }
            else if (!string.IsNullOrEmpty(registeredType.OverrideTypeName))
            {
                sb.Append($", {registeredType.OverrideTypeName}");
            }
            sb.AppendLine(">();");
        }

        sb.AppendLine();

        // Generate RegisterType calls
        foreach (var registeredType in schemaClass.RegisteredGraphTypes)
        {
            sb.AppendLine($"{indent}    RegisterType(typeof({registeredType.FullyQualifiedGraphTypeName}));");
        }

        sb.AppendLine();

        // Generate RegisterTypeMapping calls
        foreach (var typeMapping in schemaClass.TypeMappings)
        {
            sb.AppendLine($"{indent}    RegisterTypeMapping(typeof({typeMapping.FullyQualifiedClrTypeName}), typeof({typeMapping.FullyQualifiedGraphTypeName}));");
        }

        sb.AppendLine();

        // Configure root types
        if (!string.IsNullOrEmpty(schemaClass.QueryRootTypeName))
        {
            sb.AppendLine($"{indent}    Query = GetRequiredService<{schemaClass.QueryRootTypeName}>();");
        }
        if (!string.IsNullOrEmpty(schemaClass.MutationRootTypeName))
        {
            sb.AppendLine($"{indent}    Mutation = GetRequiredService<{schemaClass.MutationRootTypeName}>();");
        }
        if (!string.IsNullOrEmpty(schemaClass.SubscriptionRootTypeName))
        {
            sb.AppendLine($"{indent}    Subscription = GetRequiredService<{schemaClass.SubscriptionRootTypeName}>();");
        }

        sb.AppendLine();

        // Generate list converter registrations
        GenerateListConverterRegistrations(sb, indentLevel, schemaClass);

        sb.AppendLine($"{indent}    foreach (var listType in _listConverters.Keys)");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        ValueConverter.RegisterListConverterFactory(listType, this);");
        sb.AppendLine($"{indent}    }}");

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private static void GenerateListConverterRegistrations(StringBuilder sb, int indentLevel, SchemaClassData schemaClass)
    {
        var indent = new string(' ', indentLevel * 4);

        // Generate array list type converters
        foreach (var arrayTypeData in schemaClass.ArrayListTypes)
        {
            sb.AppendLine($"{indent}    {{");

            var elementType = arrayTypeData.ElementTypeName;
            var defaultValue = arrayTypeData.IsNullable ? ")value" : "?)value ?? default";

            sb.AppendLine($"{indent}        var converter = new global::GraphQL.Conversion.ListConverter(typeof({elementType}), values => global::System.Array.ConvertAll(values, value => ({elementType}{defaultValue}));");
            sb.AppendLine($"{indent}        _listConverters[typeof({elementType}[])] = converter;");

            // Add related generic list types
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.IEnumerable<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.IList<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.ICollection<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.IReadOnlyCollection<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.IReadOnlyList<{elementType}>)] = converter;");

            sb.AppendLine($"{indent}    }}");
        }

        // Generate generic list type converters
        foreach (var genericListTypeData in schemaClass.GenericListTypes)
        {
            var elementType = genericListTypeData.ElementTypeName;
            var defaultValue = genericListTypeData.IsNullable ? ")value" : "?)value ?? default";

            sb.AppendLine($"{indent}    _listConverters[typeof(global::System.Collections.Generic.List<{elementType}>)] = new global::GraphQL.Conversion.ListConverter(typeof({elementType}), values => global::System.Array.ConvertAll(values, value => ({elementType}{defaultValue}));");
        }

        // Generate HashSet type converters
        foreach (var hashSetTypeData in schemaClass.HashSetTypes)
        {
            sb.AppendLine($"{indent}    {{");

            var elementType = hashSetTypeData.ElementTypeName;
            var defaultValue = hashSetTypeData.IsNullable ? ")value" : "?)value ?? default";

            sb.AppendLine($"{indent}        var converter = new global::GraphQL.Conversion.ListConverter(typeof({elementType}), values => global::System.Array.ConvertAll(values, value => ({elementType}{defaultValue}));");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.HashSet<{elementType}>)] = converter;");
            sb.AppendLine($"{indent}        _listConverters[typeof(global::System.Collections.Generic.ISet<{elementType}>)] = converter;");

            sb.AppendLine($"{indent}    }}");
        }

        if (schemaClass.ArrayListTypes.Count > 0 || schemaClass.GenericListTypes.Count > 0 || schemaClass.HashSetTypes.Count > 0)
        {
            sb.AppendLine();
        }
    }

    private static void GenerateListConverterInfrastructure(StringBuilder sb, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);

        sb.AppendLine($"{indent}private readonly global::System.Collections.Generic.Dictionary<global::System.Type, global::GraphQL.Conversion.IListConverter> _listConverters = new();");
        sb.AppendLine();
        sb.AppendLine($"{indent}public global::GraphQL.Conversion.IListConverter Create(global::System.Type listType)");
        sb.AppendLine($"{indent}{{");
        sb.AppendLine($"{indent}    return _listConverters[listType];");
        sb.AppendLine($"{indent}}}");
    }
}
