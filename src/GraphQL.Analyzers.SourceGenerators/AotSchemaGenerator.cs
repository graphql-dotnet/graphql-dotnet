using System.Text;
using GraphQL.Analyzers.SourceGenerators.Models;
using GraphQL.Analyzers.SourceGenerators.Providers;
using GraphQL.Analyzers.SourceGenerators.Transformers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace GraphQL.Analyzers.SourceGenerators;

/// <summary>
/// Incremental source generator for AOT-compiled GraphQL schemas.
/// Generates partial class implementations for classes decorated with AOT attributes.
/// </summary>
[Generator]
public class AotSchemaGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get all candidate classes
        var candidateClasses = CandidateProvider.Create(context);

        // Combine with known symbols if needed
        var knownSymbols = KnownSymbolsProvider.Create(context);

        var candidatesWithSymbols = candidateClasses.Combine(knownSymbols);

        var processedCandidates = candidatesWithSymbols.SelectMany((pair, _) =>
        {
            var candidate = pair.Left;
            var symbols = pair.Right;
            var schemaData = CandidateClassTransformer.Transform(candidate, symbols);
            if (!schemaData.HasValue)
                return Array.Empty<GeneratedTypeEntry>();
            var data = SchemaAttributeDataTransformer.Transform(schemaData.Value, symbols);
            var generatedTypeData = GeneratedTypeDataTransformer.Transform(data, symbols);
            if (generatedTypeData == null)
                return Array.Empty<GeneratedTypeEntry>();
            return generatedTypeData;
        });

        // Register source output for each candidate class
        context.RegisterSourceOutput(candidateClasses, GenerateSource);
    }

    private static void GenerateSource(SourceProductionContext context, CandidateClass candidate)
    {
        // Extract class information from syntax
        var classDeclaration = candidate.ClassDeclarationSyntax;
        var classSymbol = candidate.ClassSymbol;

        var className = classDeclaration.Identifier.Text;

        // Get namespace from class symbol
        var namespaceName = string.Empty;
        if (classSymbol.ContainingNamespace != null && !classSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        }

        // Generate the source code
        var sourceCode = GeneratePartialClass(namespaceName, className);

        // Add the generated source
        var fileName = $"{className}.g.cs";
        context.AddSource(fileName, SourceText.From(sourceCode, Encoding.UTF8));
    }

    private static string GeneratePartialClass(string namespaceName, string className)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {className}");
        sb.AppendLine("{");
        sb.AppendLine("    // generated code here");
        sb.Append("}");

        return sb.ToString();
    }
}
