// SUCCESS:

// ========= FieldInterceptors__15_9_.g.cs ============

// <auto-generated/>
#nullable enable

namespace System.Runtime.CompilerServices
{
    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : global::System.Attribute
    {
        public InterceptsLocationAttribute(int version, string data)
        {
            Version = version;
            Data = data;
        }

        public int Version { get; }
        public string Data { get; }
    }
}

namespace GraphQL.Analyzers.Interceptors
{
    internal static partial class FieldInterceptors
    {
        // (15,9)
        [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(1, "DGo5ghIQa6Hupx7klBaw4QcBAAA=")]
        internal static global::GraphQL.Builders.FieldBuilder<global::Sample.Person, global::System.Threading.Tasks.Task<string>> Field__15_9_<TGraphType>(
            this global::GraphQL.Types.ComplexGraphType<global::Sample.Person> graphType,
            string name,
            global::System.Linq.Expressions.Expression<global::System.Func<global::Sample.Person, global::System.Threading.Tasks.Task<string>>> expression)
            where TGraphType : global::GraphQL.Types.ComplexGraphType<global::Sample.Person>
        {
            // Use FieldBuilderHelpers to create the field without setting ExpressionFieldResolver
            // This allows AOT compilation while still setting up the field metadata
            var builder = global::GraphQL.Utilities.FieldBuilderHelpers.CreateFieldBuilder<global::Sample.Person, global::System.Threading.Tasks.Task<string>>(
                graphType,
                name,
                expression,
                nullable: null,
                type: null,
                resolver: null);

            graphType.AddField(builder.FieldType);
            return builder;
        }
    }
}
